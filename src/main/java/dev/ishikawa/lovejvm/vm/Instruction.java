package dev.ishikawa.lovejvm.vm;


import java.util.Arrays;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

enum Instruction {
  NOP((byte) 0x00),
  ACONST_NULL((byte) 0x01),
  ICONST_M1((byte) 0x02),
  ICONST_0((byte) 0x03),
  ICONST_1((byte) 0x04),
  ICONST_2((byte) 0x05),
  ICONST_3((byte) 0x06),
  ICONST_4((byte) 0x07),
  ICONST_5((byte) 0x08),
  LCONST_0((byte) 0x09),
  LCONST_1((byte) 0x0a),
  FCONST_0((byte) 0x0b),
  FCONST_1((byte) 0x0c),
  FCONST_2((byte) 0x0d),
  DCONST_0((byte) 0x0e),
  DCONST_1((byte) 0x0f),
  BIPUSH((byte) 0x10),
  SIPUSH((byte) 0x11),
  LDC((byte) 0x12),
  LDC_W((byte) 0x13),
  LDC2_W((byte) 0x14),
  ILOAD((byte) 0x15),
  LLOAD((byte) 0x16),
  FLOAD((byte) 0x17),
  DLOAD((byte) 0x18),
  ALOAD((byte) 0x19),
  ILOAD_0((byte) 0x1a),
  ILOAD_1((byte) 0x1b),
  ILOAD_2((byte) 0x1c),
  ILOAD_3((byte) 0x1d),
  LLOAD_0((byte) 0x1e),
  LLOAD_1((byte) 0x1f),
  LLOAD_2((byte) 0x20),
  LLOAD_3((byte) 0x21),
  FLOAD_0((byte) 0x22),
  FLOAD_1((byte) 0x23),
  FLOAD_2((byte) 0x24),
  FLOAD_3((byte) 0x25),
  DLOAD_0((byte) 0x26),
  DLOAD_1((byte) 0x27),
  DLOAD_2((byte) 0x28),
  DLOAD_3((byte) 0x29),
  ALOAD_0((byte) 0x2a),
  ALOAD_1((byte) 0x2b),
  ALOAD_2((byte) 0x2c),
  ALOAD_3((byte) 0x2d),
  IALOAD((byte) 0x2e),
  LALOAD((byte) 0x2f),
  FALOAD((byte) 0x30),
  DALOAD((byte) 0x31),
  AALOAD((byte) 0x32),
  BALOAD((byte) 0x33),
  CALOAD((byte) 0x34),
  SALOAD((byte) 0x35),
  ISTORE((byte) 0x36),
  LSTORE((byte) 0x37),
  FSTORE((byte) 0x38),
  DSTORE((byte) 0x39),
  ASTORE((byte) 0x3a),
  ISTORE_0((byte) 0x3b),
  ISTORE_1((byte) 0x3c),
  ISTORE_2((byte) 0x3d),
  ISTORE_3((byte) 0x3e),
  LSTORE_0((byte) 0x3f),
  LSTORE_1((byte) 0x40),
  LSTORE_2((byte) 0x41),
  LSTORE_3((byte) 0x42),
  FSTORE_0((byte) 0x43),
  FSTORE_1((byte) 0x44),
  FSTORE_2((byte) 0x45),
  FSTORE_3((byte) 0x46),
  DSTORE_0((byte) 0x47),
  DSTORE_1((byte) 0x48),
  DSTORE_2((byte) 0x49),
  DSTORE_3((byte) 0x4a),
  ASTORE_0((byte) 0x4b),
  ASTORE_1((byte) 0x4c),
  ASTORE_2((byte) 0x4d),
  ASTORE_3((byte) 0x4e),
  IASTORE((byte) 0x4f),
  LASTORE((byte) 0x50),
  FASTORE((byte) 0x51),
  DASTORE((byte) 0x52),
  AASTORE((byte) 0x53),
  BASTORE((byte) 0x54),
  CASTORE((byte) 0x55),
  SASTORE((byte) 0x56),
  POP((byte) 0x57),
  POP2((byte) 0x58),
  DUP((byte) 0x59),
  DUP_X1((byte) 0x5a),
  DUP_X2((byte) 0x5b),
  DUP2((byte) 0x5c),
  DUP2_X1((byte) 0x5d),
  DUP2_X2((byte) 0x5e),
  SWAP((byte) 0x5f),
  IADD((byte) 0x60),
  LADD((byte) 0x61),
  FADD((byte) 0x62),
  DADD((byte) 0x63),
  ISUB((byte) 0x64),
  LSUB((byte) 0x65),
  FSUB((byte) 0x66),
  DSUB((byte) 0x67),
  IMUL((byte) 0x68),
  LMUL((byte) 0x69),
  FMUL((byte) 0x6a),
  DMUL((byte) 0x6b),
  IDIV((byte) 0x6c),
  LDIV((byte) 0x6d),
  FDIV((byte) 0x6e),
  DDIV((byte) 0x6f),
  IREM((byte) 0x70),
  LREM((byte) 0x71),
  FREM((byte) 0x72),
  DREM((byte) 0x73),
  INEG((byte) 0x74),
  LNEG((byte) 0x75),
  FNEG((byte) 0x76),
  DNEG((byte) 0x77),
  ISHL((byte) 0x78),
  LSHL((byte) 0x79),
  ISHR((byte) 0x7a),
  LSHR((byte) 0x7b),
  IUSHR((byte) 0x7c),
  LUSHR((byte) 0x7d),
  IAND((byte) 0x7e),
  LAND((byte) 0x7f),
  IOR((byte) 0x80),
  LOR((byte) 0x81),
  IXOR((byte) 0x82),
  LXOR((byte) 0x83),
  IINC((byte) 0x84),
  I2L((byte) 0x85),
  I2F((byte) 0x86),
  I2D((byte) 0x87),
  L2I((byte) 0x88),
  L2F((byte) 0x89),
  L2D((byte) 0x8a),
  F2I((byte) 0x8b),
  F2L((byte) 0x8c),
  F2D((byte) 0x8d),
  D2I((byte) 0x8e),
  D2L((byte) 0x8f),
  D2F((byte) 0x90),
  I2B((byte) 0x91),
  I2C((byte) 0x92),
  I2S((byte) 0x93),
  LCMP((byte) 0x94),
  FCMPL((byte) 0x95),
  FCMPG((byte) 0x96),
  DCMPL((byte) 0x97),
  DCMPG((byte) 0x98),
  IFEQ((byte) 0x99),
  IFNE((byte) 0x9a),
  IFLT((byte) 0x9b),
  IFGE((byte) 0x9c),
  IFGT((byte) 0x9d),
  IFLE((byte) 0x9e),
  IF_ICMPEQ((byte) 0x9f),
  IF_ICMPNE((byte) 0xa0),
  IF_ICMPLT((byte) 0xa1),
  IF_ICMPGE((byte) 0xa2),
  IF_ICMPGT((byte) 0xa3),
  IF_ICMPLE((byte) 0xa4),
  IF_ACMPEQ((byte) 0xa5),
  IF_ACMPNE((byte) 0xa6),
  GOTO((byte) 0xa7),
  JSR((byte) 0xa8),
  RET((byte) 0xa9),
  TABLESWITCH((byte) 0xaa),
  LOOKUPSWITCH((byte) 0xab),
  IRETURN((byte) 0xac),
  LRETURN((byte) 0xad),
  FRETURN((byte) 0xae),
  DRETURN((byte) 0xaf),
  ARETURN((byte) 0xb0),
  RETURN((byte) 0xb1),
  GETSTATIC((byte) 0xb2),
  PUTSTATIC((byte) 0xb3),
  GETFIELD((byte) 0xb4),
  PUTFIELD((byte) 0xb5),
  INVOKEVIRTUAL((byte) 0xb6),
  INVOKESPECIAL((byte) 0xb7),
  INVOKESTATIC((byte) 0xb8),
  INVOKEINTERFACE((byte) 0xb9),
  INVOKEDYNAMIC((byte) 0xba),
  NEW((byte) 0xbb),
  NEWARRAY((byte) 0xbc),
  ANEWARRAY((byte) 0xbd),
  ARRAYLENGTH((byte) 0xbe),
  ATHROW((byte) 0xbf),
  CHECKCAST((byte) 0xc0),
  INSTANCEOF((byte) 0xc1),
  MONITORENTER((byte) 0xc2),
  MONITOREXIT((byte) 0xc3),
  WIDE((byte) 0xc4),
  MULTIANEWARRAY((byte) 0xc5),
  IFNULL((byte) 0xc6),
  IFNONNULL((byte) 0xc7),
  GOTO_W((byte) 0xc8),
  JSR_W((byte) 0xc9),
  BREAKPOINT((byte) 0xca),
  IMPDEP1((byte) 0xfe),
  IMPDEP2((byte) 0xff);

  private final byte operandCode;

  Instruction(byte operandCode) {
    this.operandCode = operandCode;
  }

  public byte getOperandCode() {
    return operandCode;
  }

  private static Map<Byte, Instruction> entryMap =
      Arrays.stream(Instruction.values())
          .collect(Collectors.toMap(Instruction::getOperandCode, Function.identity()));

  /** REFACTOR: check OBJECT_REFERENCE is ok as a default value or not. */
  public static Instruction findBy(byte operandCode) {
    return entryMap.get(operandCode);
  }
}
